<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Exporter slides d'un ODP</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;max-width:820px;margin:32px auto;padding:0 16px;color:#111}
    h1{font-size:1.4rem;margin-bottom:8px}
    label{display:inline-block;margin:8px 0}
    button{margin-top:12px;padding:10px 14px;border-radius:8px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
    pre{background:#f4f4f4;padding:12px;border-radius:8px;overflow:auto}
  </style>
  <!-- CDN pour JSZip et FileSaver -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
  <h1>Exporter chaque slide d'un .odp en fichiers .odp séparés</h1>
  <p>Choisissez un fichier <code>.odp</code> (présent sur votre PC) ; le script créera un .odp par diapositive et lancera le téléchargement.</p>

  <label>
    Fichier .odp :
    <input id="fileInput" type="file" accept=".odp,application/vnd.oasis.opendocument.presentation"/>
  </label>
  <br/>
  <button id="processBtn">Exporter les slides</button>

  <div id="log" style="margin-top:16px"></div>

<script>
(async () => {
  const fileInput = document.getElementById('fileInput');
  const btn = document.getElementById('processBtn');
  const logEl = document.getElementById('log');

  function log(msg, isError=false){
    const p = document.createElement('div');
    p.textContent = msg;
    p.style.color = isError ? 'crimson' : '#222';
    logEl.appendChild(p);
  }

  // helper pour parser XML en Document
  function parseXml(txt){
    return new DOMParser().parseFromString(txt, 'application/xml');
  }

  // récupère tous les éléments <draw:page> de façon robuste
  function getDrawPages(doc){
    // essayer par préfixe
    let pages = Array.from(doc.getElementsByTagName('draw:page'));
    if (pages.length) return pages;
    // fallback : rechercher par localName 'page'
    pages = Array.from(doc.getElementsByTagName('*')).filter(el => el.localName === 'page');
    return pages;
  }

  btn.addEventListener('click', async () => {
    logEl.innerHTML = '';
    const file = fileInput.files && fileInput.files[0];
    if (!file) { log('Choisissez un fichier .odp d’abord.', true); return; }
    log(`Lecture de ${file.name}...`);

    try {
      const arrayBuffer = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(arrayBuffer);

      // lire mimetype (doit être fichier texte)
      const mimetypeFile = zip.file('mimetype');
      const mimetypeContent = mimetypeFile ? await mimetypeFile.async('string') : 'application/vnd.oasis.opendocument.presentation';
      log(`mimetype: ${mimetypeContent}`);

      // lire content.xml (obligatoire)
      const contentFile = zip.file('content.xml');
      if (!contentFile) { log('Erreur : content.xml introuvable dans le .odp', true); return; }
      const contentTxt = await contentFile.async('string');
      const contentDoc = parseXml(contentTxt);

      // extraire pages
      const pages = getDrawPages(contentDoc);
      if (!pages.length) { log('Aucune <draw:page> trouvée dans content.xml', true); return; }
      log(`${pages.length} pages trouvées — création de fichiers .odp individuels...`);

      // conserver certains fichiers à recopier (s'ils existent)
      const copyPaths = ['styles.xml','meta.xml','settings.xml','META-INF/manifest.xml'];
      const extraFiles = {};
      for (const p of copyPaths) {
        const f = zip.file(p);
        if (f) extraFiles[p] = await f.async('uint8array');
      }

      // récupérer l'en-tête et le pied du content.xml pour garder le wrapper correct
      // méthode : string manipulation — on reconstruit content.xml en remplaçant toutes les draw:page par une seule
      // trouver début et fin des pages dans le texte original
      const firstPageMatch = contentTxt.match(/<draw:page[\s\S]*?<\/draw:page>/);
      if (!firstPageMatch) { log('Impossible d’identifier les balises <draw:page> via texte — arrêt.', true); return; }
      const beforePages = contentTxt.slice(0, firstPageMatch.index);
      const lastPageMatch = contentTxt.match(/<draw:page[\s\S]*<\/draw:page>/g);
      const lastMatch = lastPageMatch[lastPageMatch.length-1];
      const afterPages = contentTxt.slice(contentTxt.lastIndexOf(lastMatch) + lastMatch.length);

      // pour chaque page, construire un nouveau content.xml avec uniquement cette page et zipper
      let i = 0;
      for (const pageEl of pages) {
        i++;
        // serializer pageEl vers string (XML)
        const serializer = new XMLSerializer();
        const pageXml = serializer.serializeToString(pageEl);

        // reconstruire content.xml
        const newContent = beforePages + pageXml + afterPages;

        // créer nouveau zip
        const newZip = new JSZip();
        // ajouter mimetype sans compression (STORE)
        newZip.file('mimetype', mimetypeContent, { binary: false, compression:'STORE' });

        // ajouter les autres fichiers (styles, meta, settings, manifest) si présents
        for (const [path, data] of Object.entries(extraFiles)) {
          newZip.file(path, data);
        }

        // ajouter content.xml (compressé)
        newZip.file('content.xml', newContent);

        // conserver éventuellement d'autres dossiers/images du zip original (images, Thumbnails, etc.)
        // on copie les entrées sous "Pictures/" et "Thumbnails/" et tout ce qui est dans "Pictures" ou "Thumbnails"
        zip.folder('Pictures') && zip.folder('Pictures').forEach && zip.folder('Pictures').forEach((relativePath, fileEntry) => {});
        // copie basique : parcourir toutes les entrées et copier celles qui ne sont déjà ajoutées et qui sont utiles
        zip.forEach((relativePath, fileEntry) => {
          // ignorer les fichiers que nous avons déjà gérés
          if (['mimetype','content.xml','styles.xml','meta.xml','settings.xml','META-INF/manifest.xml'].includes(relativePath)) return;
          // garder images et dossiers usuels
          if (relativePath.startsWith('Pictures/') || relativePath.startsWith('Thumbnails/') || relativePath.startsWith('META-INF/') ) {
            // copie en binaire
            newZip.file(relativePath, fileEntry.async('uint8array'));
          }
        });

        // attendre la copie effective (les promesses pour les fichiers ajoutés)
        // JSZip permet file content as promise; on finalise l'archive:
        const blob = await newZip.generateAsync({type:'blob',compression:'DEFLATE'});

        // nom de fichier
        const baseName = file.name.replace(/\.odp$/i,'') || 'presentation';
        const outName = `${baseName}_slide-${String(i).padStart(2,'0')}.odp`;
        saveAs(blob, outName);
        log(`Téléchargement lancé : ${outName}`);
      }

      log('Terminé.');
    } catch (err) {
      console.error(err);
      log('Erreur : ' + (err && err.message ? err.message : String(err)), true);
    }
  });
})();
</script>
</body>
</html>
